# File simon45s.asm
0000			;;; SIMON version 4.5s 
0000			;;; 
0000			;;; Source recreated by disassembly; all comments inferred from code inspection 
0000			;;; 
0000			;;; 2Kbyte ROM decoded at address $F000 
0000			;;; Can boot automatically if disk present, else enter command-loop supporting these commands: 
0000			;;; 
0000			;;; A                - ?? boot 5.25" disk 
0000			;;; B 
0000			;;; C ffff tttt cccc - copy cccc bytes from ffff to tttt. Can overwrite if regions overlap 
0000			;;; G aaaa           - go (execute) at address aaaa 
0000			;;; F ffff cccc vv   - fill from ffff for cccc bytes with value vv 
0000			;;; S aaaa           - inspect and modify memory at address aaaa 
0000			;;; O pp vv          - output (write) value vv to I/O port pp 
0000			;;; Q pp             - query (read) value from I/O port pp 
0000			;;; D ffff cc        - display memory from ffff - cc lines of 16 bytes-per-line 
0000			;;; V                - print SIMON version number 
0000			;;; 8                - ?? boot 8" disk 
0000			 
0000			L_0002: equ $0002               ; entry point of loaded boot sector 
0000			L_00E6: equ $00E6               ; 1st entry in JPTAB1 or JPTAB2 POLL STATUS 
0000			L_00E9: equ $00E9               ; 2nd entry in JPTAB1 or JPTAB2 GET CHAR 
0000			L_00EC: equ $00EC               ; 3rd entry in JPTAB1 or JPTAB2 PUT CHAR 
0000			 
0000			;;; Ports for GM811/GM813 CPU board 
0000			 
0000			KBD:    equ $B0                 ; keyboard - GM811 only 
0000			 
0000			PIOADAT:equ $B4 
0000			PIOBDAT:equ $B5 
0000			PIOACTL:equ $B6 
0000			PIOBCTL:equ $B7 
0000			 
0000			MMAP:   equ $FE                 ; memory mapper - GM813 only 
0000			PMOD:   equ $FF                 ; page mode     - GM813 only 
0000			 
0000			UARTDAT:equ $B8                 ; data holding 
0000			UARTIE: equ $B9                 ; interrupt enable         UNUSED HERE 
0000			UARTII: equ $BA                 ; interrupt identification UNUSED HERE 
0000			UARTLC: equ $BB                 ; line control             UNUSED HERE 
0000			UARTMC: equ $BC                 ; modem control 
0000			UARTLS: equ $BD                 ; line status 
0000			UARTMS: equ $BE                 ; modem status 
0000			 
0000			 
0000			;;; Ports for IVC board 
0000			IVCDAT: equ $B1    ;data (r/w) 
0000			IVCSTA: equ $B2    ;status (ro) 
0000			IVCRST: equ $B3    ;reset (r/w) 
0000			 
0000			;;; Ports for FDC board 
0000			FDCCMD: equ $E0    ;1793 command register 
0000			FDCSTA: equ $E0    ;1793 status register 
0000			FDCTRK: equ $E1    ;1793 track register 
0000			FDCSEC: equ $E2    ;1793 sector register 
0000			FDCDAT: equ $E3    ;1793 data register 
0000			FDCDRV: equ $E4    ;FDC card drive select port 
0000			SCSCTL: equ $E5    ;SCSI control lines - only on GM849 
0000			SCSDAT: equ $E6    ;SCSI data - only on GM849 
0000			 
0000			 
0000			        org $F000 
f000			 
f000			;;; After reset, the ROM is decoded at 0 and throughout the address map. After the 
f000			;;; first write to port 0xFF, the ROM is only decoded at 0xFXXX. Before that write, 
f000			;;; there must be a jump to 0xFXXX. ROM can be disabled by setting port 0xBC[3]=1 
f000			 
f000			;;; Documented entry points for user-accessible subroutines 
f000 c3 33 f0		COLD:   jp XCOLD 
f003 c3 ca f3		CHRIN:  jp XCHRIN 
f006 c3 cd f3		CHROUT: jp XCHROUT 
f009 c3 ce f5		P2HEX:  jp XP2HEX 
f00c c3 c9 f5		P4HEX:  jp XP4HEX 
f00f c3 e7 f5		SPACE:  jp XSPACE 
f012 c3 e2 f5		CRLF:   jp XCRLF 
f015			 
f015			 
f015 ..			MSG1:   defm "(C) dci software" ; TODO never referenced 
f025			 
f025 0d			MSG20:  defb $0D                ; printed by V (version) command 
f026 ..			        defm "10-03-87 "        ; (falls through to print the mG CR also) 
f02f			 
f02f ..			MSG19:  defm "mG"               ; magic compared with first 2 bytes of boot sector 
f031 0d 00		        defb $0D, $00 
f033			 
f033 db b3		XCOLD:  in a, (IVCRST)          ; reset IVC 
f035 3e 01		        ld a, $01 
f037 d3 e4		        out (FDCDRV), a         ; select drive 0/A 
f039 16 40		        ld d, $40               ; count ??of mapper pages to init?? 
f03b 01 fe f0		CLOP1:  ld bc, $F0FE            ; B=?? C= port for MMAP 
f03e 1e 0f		        ld e, $0F               ; value? 
f040 ed 59		CLOP2:  out (c), e              ; initialise memory mapper 
f042 1d			        dec e 
f043 78			        ld a, b 
f044 d6 10		        sub $10 
f046 47			        ld b, a 
f047 30 f7		        jr nc, CLOP2            ; continue 
f049 15			        dec d 
f04a 20 ef		        jr nz, CLOP1            ; 0x64 = 40 
f04c 3e 11		        ld a, $11               ; value? 
f04e d3 ff		        out (PMOD), a           ; page-mode register 
f050 31 e6 00		        ld sp, L_00E6 
f053 cd e7 f1		        call L_F1E7             ; Will execute at FXXX instead of 0XXX 
f056			                                ; BUT: how does the ROM get disabled so that the 
f056			                                ; stack at $000E6 can be used?? 
f056 ed 57		        ld a, i                 ;  
f058 3e 01		        ld a, $01               ;  
f05a f5			        push af                 ; TODO wot's appenin? could this be some kind of warm/cold check? 
f05b ed 47		        ld i, a                 ;  
f05d f1			        pop af                  ;  
f05e 28 03		        jr z, L_F063            ;  
f060 3a ef 00		        ld a, ($00EF)           ; drive select value for boot drive 
f063 32 ef 00		L_F063: ld ($00EF), a           ; comes here from A and B commands 
f066 f5			        push af 
f067 3e f3		        ld a, $F3 
f069 d3 e5		        out (SCSCTL), a 
f06b 3e 09		        ld a, $09 
f06d 3d			L_F06D: dec a 
f06e 20 fd		        jr nz, L_F06D 
f070 3e f7		        ld a, $F7 
f072 d3 e5		        out (SCSCTL), a 
f074 21 ac f4		        ld hl, MSG8             ; clear screen, power-on message 
f077 cd 9f f3		        call PRS 
f07a f1			        pop af 
f07b 20 60		        jr nz, L_F0DD 
f07d c3 4d f1		        jp L_F14D 
f080			 
f080 ..			MSG2:   defm " while loading Boot sector" 
f09a 00			        defb $00 
f09b			 
f09b ..			MSG3:   defm " during System load" 
f0ae 00			        defb $00 
f0af			 
f0af			;;; TODO how is this used? 
f0af c0 d2 c5 c1 c4 80 c5 d2 d2 cf d2 c0 00	MSG4:   defb $C0, $D2, $C5, $C1, $C4, $80, $C5, $D2, $D2, $CF, $D2, $C0, $00 
f0bc			 
f0bc ..			MSG5:   defm " - Press any key to repeat<" 
f0d7 00			        defb $00 
f0d8			 
f0d8 21 80 f0		L_F0D8: ld hl, MSG2             ; (error) while loading Boot sector 
f0db 18 03		        jr L_F0E0 
f0dd			 
f0dd 21 9b f0		L_F0DD: ld hl, MSG3             ; (error) during System load 
f0e0 e5			L_F0E0: push hl 
f0e1 21 af f0		        ld hl, MSG4             ; ?? 
f0e4 cd 9f f3		        call PRS 
f0e7 e1			        pop hl 
f0e8 cd 9f f3		        call PRS 
f0eb 21 bc f0		        ld hl, MSG5             ; - Press any key to repeat< 
f0ee cd 9f f3		L_F0EE: call PRS 
f0f1 cd 7c f2		L_F0F1: call L_F27C 
f0f4 28 02		        jr z, L_F0F8 
f0f6 30 f9		        jr nc, L_F0F1 
f0f8 cd b5 f2		L_F0F8: call L_F2B5 
f0fb 18 50		        jr L_F14D 
f0fd			 
f0fd			 
f0fd			;;; TODO how is this used? 
f0fd ..			MSG15:  defm "<" 
f0fe 09 09 09		        defb $09, $09, $09 
f101 ..			        defm "<" 
f102 09 80 c9 ee f3 e5 f2 f4 80 c4 e9 f3 eb 80 e9 ee 00	        defb $09, $80, $C9, $EE, $F3, $E5, $F2, $F4, $80, $C4, $E9, $F3, $EB, $80, $E9, $EE, $00 
f113			 
f113 e4 f2 e9 f6 e5 80 00	MSG15A: defb $E4, $F2, $E9, $F6, $E5, $80, $00 ;TODO no reference 
f11a			 
f11a a0			MSG16:  defb $A0                ;TODO no reference 
f11b ..			        defm "<" 
f11c 00			        defb $00 
f11d			 
f11d 21 fd f0		L_F11D: ld hl, MSG15 
f120 cd 9f f3		        call PRS 
f123 3a ef 00		        ld a, ($00EF)           ; get drive 
f126 06 c0		        ld b, $C0 
f128 04			L_F128: inc b 
f129 0f			        rrca 
f12a 30 fc		        jr nc, L_F128 
f12c 78			        ld a, b 
f12d fe c1		        cp $C1 
f12f 28 02		        jr z, L_F133 
f131 d6 10		        sub $10 
f133 cd cd f3		L_F133: call XCHROUT 
f136 c3 9f f3		        jp PRS                  ; print and return (tail-recurse) 
f139			 
f139			 
f139 cd 1d f1		L_F139: call L_F11D 
f13c cd 77 f2		L_F13C: call WOTIO 
f13f cc 1d f1		        call z, L_F11D 
f142 cd 7c f2		        call L_F27C 
f145 cd b5 f2		        call L_F2B5 
f148 cd 7c f2		        call L_F27C 
f14b 28 ef		        jr z, L_F13C 
f14d 31 e6 00		L_F14D: ld sp, L_00E6 
f150 cd 7c f2		        call L_F27C 
f153 28 e4		        jr z, L_F139 
f155 3c			        inc a 
f156 28 05		        jr z, L_F15D 
f158 cd 6e f3		        call L_F36E 
f15b 18 13		        jr L_F170 
f15d			 
f15d			 
f15d db e0		L_F15D: in a, (FDCSTA) 
f15f cb 47		        bit 0, a 
f161 20 fa		        jr nz, L_F15D           ; wait until done? 
f163 3e 5b		        ld a, $5B 
f165 cd e8 f2		        call CMD2FDC            ; STEP IN? 
f168 3e 0b		        ld a, $0B 
f16a cd e8 f2		        call CMD2FDC            ; RESTORE 
f16d cd b4 f1		        call L_F1B4 
f170 b7			L_F170: or a 
f171 c2 d8 f0		        jp nz, L_F0D8 
f174 2a 00 00		        ld hl, ($0000)          ; get first 2 bytes from boot sector 
f177 ed 5b 2f f0	        ld de, (MSG19)          ; "mG" 
f17b b7			        or a 
f17c ed 52		        sbc hl, de 
f17e cc b8 f2		        call z, L_F2B8          ; if good disk?? 
f181 3a ef 00		        ld a, ($00EF)           ; get drive 
f184 ca 02 00		        jp z, L_0002            ; enter code loaded from boot sector (first 2 bytes is "magic" eg GG for Gemini) 
f187 21 8d f1		        ld hl, MSG17            ; ??wot?? 
f18a c3 ee f0		        jp L_F0EE 
f18d			 
f18d			 
f18d			;;; TODO how is this used? 
f18d 09 80 c0 ce ef 80 c4 d8 80 b3 80 c3 d0 af cd 80	MSG17:  defb $09, $80, $C0, $CE, $EF, $80, $C4, $D8, $80, $B3, $80, $C3, $D0, $AF, $CD, $80 
f19d f3 f9 f3 f4 e5 ed 80 ef ee 80 f4 e8 e9 f3 80 e4	        defb $F3, $F9, $F3, $F4, $E5, $ED, $80, $EF, $EE, $80, $F4, $E8, $E9, $F3, $80, $E4 
f1ad e9 f3 eb c0 80	        defb $E9, $F3, $EB, $C0, $80 
f1b2 ..			        defm "<" 
f1b3 00			        defb $00 
f1b4			 
f1b4			 
f1b4 3e 0b		L_F1B4: ld a, $0B 
f1b6 cd e8 f2		        call CMD2FDC            ; RESTORE 
f1b9 3a ef 00		        ld a, ($00EF)           ; get drive 
f1bc e6 20		        and $20 
f1be 28 02		        jr z, L_F1C2 
f1c0 3e 01		        ld a, $01 
f1c2 d3 e2		L_F1C2: out (FDCSEC), a 
f1c4 21 00 00		        ld hl, $0000 
f1c7 0e e4		        ld c, FDCDRV            ; ?fast access to FDC data-available flag? 
f1c9 3e 88		        ld a, $88 
f1cb d3 e0		        out (FDCCMD), a         ; READ SECTOR 
f1cd 06 80		        ld b, $80 
f1cf 18 00		        jr L_F1D1               ; why not fall through? Bug, or need need slight delay? 
f1d1			 
f1d1			 
f1d1 ed 78		L_F1D1: in a, (c)               ; data? 
f1d3 28 fc		        jr z, L_F1D1            ; no data 
f1d5 db e3		        in a, (FDCDAT)          ; get data 
f1d7 77			        ld (hl), a              ; store 
f1d8 23			        inc hl                  ; next location 
f1d9 10 f6		        djnz L_F1D1             ; total of $80 (128) bytes 
f1db ed 78		L_F1DB: in a, (c)               ; read and discard remaining bytes, if any 
f1dd 28 fc		        jr z, L_F1DB 
f1df db e3		        in a, (FDCDAT) 
f1e1 fa db f1		        jp m, L_F1DB 
f1e4 db e0		        in a, (FDCSTA) 
f1e6 c9			        ret 
f1e7			 
f1e7			 
f1e7 db be		L_F1E7: in a, ($BE) 
f1e9 e6 40		        and $40                 ; ??check board link?? 
f1eb 32 f0 00		        ld ($00F0), a           ; record what I/O is in use 
f1ee 20 3d		        jr nz, L_F22D 
f1f0 21 65 f2		        ld hl, JPTAB1           ; use IVC for kbd/display 
f1f3 cd 5c f2		        call CP92E6 
f1f6 db b1		        in a, (IVCDAT) 
f1f8 3e 1a		        ld a, $1A               ; home/clear screen 
f1fa d3 b1		        out (IVCDAT), a 
f1fc db b2		        in a, (IVCSTA) 
f1fe 0f			        rrca 
f1ff 3f			        ccf 
f200 3e ff		        ld a, $FF 
f202 d8			        ret c 
f203 21 00 00		        ld hl, $0000 
f206 2b			L_F206: dec hl 
f207 7c			        ld a, h 
f208 b5			        or l 
f209 37			        scf 
f20a 3e ff		        ld a, $FF 
f20c c8			        ret z                   ; timeout waiting - maybe no IVC? 
f20d db b2		        in a, (IVCSTA) 
f20f 0f			        rrca 
f210 38 f4		        jr c, L_F206 
f212 21 00 00		L_F212: ld hl, $0000 
f215 3e 1b		        ld a, $1B 
f217 cd e1 f3		        call PUTIVC 
f21a 3e 76		        ld a, $76               ; get version number of IVC software 
f21c cd e1 f3		        call PUTIVC 
f21f 2b			L_F21F: dec hl 
f220 7c			        ld a, h 
f221 b5			        or l 
f222 28 ee		        jr z, L_F212            ; timeout; try again 
f224 db b2		        in a, (IVCSTA) 
f226 07			        rlca 
f227 38 f6		        jr c, L_F21F            ; wait 
f229 af			        xor a 
f22a db b1		        in a, (IVCDAT)          ; version number in A 
f22c c9			        ret 
f22d			 
f22d			 
f22d 2e 06		L_F22D: ld l, $06 
f22f 01 00 00		L_F22F: ld bc, $0000 
f232 0b			L_F232: dec bc 
f233 78			        ld a, b 
f234 b1			        or c 
f235 20 fb		        jr nz, L_F232 
f237 2d			        dec l 
f238 20 f5		        jr nz, L_F22F 
f23a 21 6e f2		        ld hl, JPTAB2           ; use UART for kbd/display 
f23d cd 5c f2		        call CP92E6 
f240 3e 66		        ld a, $66 
f242 d3 48		        out ($48), a 
f244 21 4e f2		        ld hl, XXXTAB 
f247 01 42 0e		        ld bc, $0E42 
f24a ed b3		        otir                    ; send $0E bytes to port $42 from XXXTAB 
f24c b7			        or a 
f24d c9			        ret 
f24e			 
f24e			 
f24e 00 18 04 44 03 c0 05 60 01 00 03 c1 05 68	XXXTAB: defb $00, $18, $04, $44, $03, $C0, $05, $60, $01, $00, $03, $C1, $05, $68 
f25c			 
f25c 11 e6 00		CP92E6: ld de, L_00E6           ; copy 9 bytes (3 x JP XXXX) to $00E6 
f25f 01 09 00		        ld bc, $0009 
f262 ed b0		        ldir 
f264 c9			        ret 
f265			 
f265			 
f265 c3 02 f4		JPTAB1: jp POLIVC               ; vectored I/O using IVC 
f268 c3 11 f4		        jp GETIVC 
f26b c3 e1 f3		        jp PUTIVC 
f26e c3 2f f4		JPTAB2: jp POLSER               ; vectored I/O using UART 
f271 c3 34 f4		        jp GETSER 
f274 c3 eb f3		        jp PUTSER 
f277			 
f277			 
f277 3a f0 00		WOTIO:  ld a, ($00F0)           ; says what type of I/O is in use?? 
f27a b7			        or a 
f27b c9			        ret 
f27c			 
f27c			 
f27c 3e d0		L_F27C: ld a, $D0               ; FORCE INTERRUPT 
f27e cd e8 f2		        call CMD2FDC 
f281 3a ef 00		        ld a, ($00EF)           ; get drive 
f284 d3 e4		        out (FDCDRV), a 
f286 3e 0b		        ld a, $0B 
f288 d3 e0		        out (FDCCMD), a         ; RESTORE 
f28a 06 28		        ld b, $28 
f28c 10 fe		L_F28C: djnz L_F28C 
f28e 21 00 d0		        ld hl, $D000 
f291 db e0		        in a, (FDCSTA) 
f293 4f			        ld c, a 
f294 db e0		L_F294: in a, (FDCSTA) 
f296 a9			        xor c 
f297 e6 02		        and $02 
f299 28 02		        jr z, L_F29D 
f29b 06 ff		        ld b, $FF 
f29d 2d			L_F29D: dec l 
f29e 20 f4		        jr nz, L_F294 
f2a0 cd b8 f2		        call L_F2B8 
f2a3 b7			        or a 
f2a4 37			        scf 
f2a5 c0			        ret nz 
f2a6 25			        dec h 
f2a7 20 eb		        jr nz, L_F294 
f2a9 78			        ld a, b 
f2aa b7			        or a 
f2ab c0			        ret nz 
f2ac cd f6 f2		        call L_F2F6 
f2af 20 02		        jr nz, L_F2B3 
f2b1 3c			        inc a 
f2b2 c9			        ret 
f2b3			 
f2b3			 
f2b3 af			L_F2B3: xor a 
f2b4 c9			        ret 
f2b5			 
f2b5			 
f2b5 cd d4 f2		L_F2B5: call L_F2D4 
f2b8 cd e6 00		L_F2B8: call L_00E6 
f2bb b7			        or a 
f2bc c8			        ret z 
f2bd e6 1f		        and $1F 
f2bf fe 01		        cp $01 
f2c1 ca 40 f4		        jp z, CMD_A 
f2c4 fe 18		        cp $18 
f2c6 ca 7f f4		        jp z, CMD_8 
f2c9 fe 13		        cp $13 
f2cb 3e 01		        ld a, $01 
f2cd c0			        ret nz 
f2ce cd d4 f2		        call L_F2D4 
f2d1 c3 3c f5		        jp L_F53C               ; ?did not autoboot: continue to command loop 
f2d4			 
f2d4			 
f2d4 cd 77 f2		L_F2D4: call WOTIO 
f2d7 21 e3 f2		        ld hl, MSG13            ; delete to end of line 
f2da ca 9f f3		        jp z, PRS 
f2dd 21 e6 f2		        ld hl, MSG14            ; "<" 
f2e0 c3 9f f3		        jp PRS                  ; print and return (tail-recurse) 
f2e3			 
f2e3			 
f2e3 1b 2a 00		MSG13:  defb $1B, $2A, $00      ; delete to end of line 
f2e6			 
f2e6 ..			MSG14:  defm "<" 
f2e7 00			        defb $00 
f2e8			 
f2e8			 
f2e8 d3 e0		CMD2FDC:out (FDCCMD), a         ; send command in A to FDC then wait then poll status (for completion?) 
f2ea 3e 0a		        ld a, $0A               ; delay loop count for command acceptance 
f2ec 3d			L_F2EC: dec a 
f2ed 20 fd		        jr nz, L_F2EC           ; wait a little while 
f2ef db e0		L_F2EF: in a, (FDCSTA)          ; read status 
f2f1 cb 47		        bit 0, a                ; completion? 
f2f3 20 fa		        jr nz, L_F2EF           ; not yet.. loop 
f2f5 c9			        ret                     ; done 
f2f6			 
f2f6			 
f2f6 cd 31 f3		L_F2F6: call L_F331 
f2f9 00			        nop 
f2fa 00			        nop 
f2fb 00			        nop 
f2fc 00			        nop 
f2fd 00			        nop 
f2fe 00			        nop 
f2ff c3 7a f3		        jp L_F37A 
f302			 
f302			 
f302 af			L_F302: xor a 
f303 f5			L_F303: push af 
f304 db e5		        in a, (SCSCTL) 
f306 e6 10		        and $10 
f308 28 06		        jr z, L_F310 
f30a f1			        pop af 
f30b 3d			        dec a 
f30c 20 f5		        jr nz, L_F303 
f30e 18 01		        jr L_F311 
f310			 
f310			 
f310 f1			L_F310: pop af 
f311 3e f7		L_F311: ld a, $F7 
f313 d3 e5		        out (SCSCTL), a 
f315 c9			        ret 
f316			 
f316			 
f316 db e5		L_F316: in a, (SCSCTL) 
f318 e6 10		        and $10 
f31a 3e 01		        ld a, $01 
f31c c0			        ret nz 
f31d db e5		L_F31D: in a, (SCSCTL) 
f31f 0f			        rrca 
f320 38 fb		        jr c, L_F31D 
f322 c9			        ret 
f323			 
f323			 
f323 3e ff		L_F323: ld a, $FF 
f325 d3 e6		        out (SCSDAT), a 
f327 06 00		        ld b, $00 
f329 db e6		L_F329: in a, (SCSDAT) 
f32b 10 fc		        djnz L_F329 
f32d 3e 04		        ld a, $04 
f32f a7			        and a 
f330 c9			        ret 
f331			 
f331			 
f331 06 00		L_F331: ld b, $00 
f333 db e5		L_F333: in a, (SCSCTL) 
f335 f6 e0		        or $E0 
f337 3c			        inc a 
f338 28 04		        jr z, L_F33E 
f33a 10 f7		        djnz L_F333 
f33c 18 e5		        jr L_F323 
f33e			 
f33e			 
f33e 3e fe		L_F33E: ld a, $FE 
f340 d3 e6		        out (SCSDAT), a 
f342 3e f5		        ld a, $F5 
f344 d3 e5		        out (SCSCTL), a 
f346 cd 02 f3		        call L_F302 
f349 e1			        pop hl 
f34a cd 16 f3		        call L_F316 
f34d 7e			        ld a, (hl) 
f34e 2f			        cpl 
f34f d3 e6		        out (SCSDAT), a 
f351 23			        inc hl 
f352 23			        inc hl 
f353 cd 16 f3		        call L_F316 
f356 3a ef 00		        ld a, ($00EF)           ; get drive 
f359 3d			        dec a 
f35a 28 02		        jr z, L_F35E 
f35c 3e 20		        ld a, $20 
f35e 2f			L_F35E: cpl 
f35f d3 e6		        out (SCSDAT), a 
f361 06 04		        ld b, $04 
f363 cd 16 f3		L_F363: call L_F316 
f366 7e			        ld a, (hl) 
f367 2f			        cpl 
f368 d3 e6		        out (SCSDAT), a 
f36a 23			        inc hl 
f36b 10 f6		        djnz L_F363 
f36d e9			        jp (hl) 
f36e			 
f36e			 
f36e cd 31 f3		L_F36E: call L_F331 
f371 08			        ex af, af' 
f372 00			        nop 
f373 00			        nop 
f374 00			        nop 
f375 01 00 21		        ld bc, $2100 
f378 00			        nop 
f379 00			        nop 
f37a cd 16 f3		L_F37A: call L_F316 
f37d 0f			        rrca 
f37e 38 a3		        jr c, L_F323 
f380 0f			        rrca 
f381 30 0c		        jr nc, L_F38F 
f383 db e6		        in a, (SCSDAT) 
f385 2f			        cpl 
f386 77			        ld (hl), a 
f387 7d			        ld a, l 
f388 fe 7f		        cp $7F 
f38a 28 ee		        jr z, L_F37A 
f38c 23			        inc hl 
f38d 08			        ex af, af' 
f38e eb			        ex de, hl 
f38f			 
f38f			L_F38F: 
f38f cb e6		        set 4, (hl) 
f391 2f			        cpl 
f392 47			        ld b, a 
f393 cd 16 f3		        call L_F316 
f396 0f			        rrca 
f397 38 8a		        jr c, L_F323 
f399 db e6		        in a, (SCSDAT) 
f39b 78			        ld a, b 
f39c e6 0f		        and $0F 
f39e c9			        ret 
f39f			 
f39f			 
f39f 6e			PRS:    ld l, (hl)              ; print 0-terminated string at (HL) 
f3a0 23			        inc hl                  ; ??with special treatment of 0x80 and others? 
f3a1 b7			        or a 
f3a2 c8			        ret z 
f3a3 fe 80		        cp $80 
f3a5 20 02		        jr nz, PRS1 
f3a7 3e a0		        ld a, $A0               ; change $80 to $A0?? 
f3a9 c5			PRS1:   push bc 
f3aa 01 20 14		        ld bc, $1420 
f3ad fe 09		        cp $09                  ; TAB translates as "print 20 spaces" 
f3af 28 10		        jr z, PRS2 
f3b1 01 2a 05		        ld bc, $052A 
f3b4 fe 40		        cp $40                  ; @ translates as "print 5 *" 
f3b6 28 09		        jr z, PRS2 
f3b8 0e aa		        ld c, $AA               ; ??? 
f3ba fe c0		        cp $C0                  ; ??? 
f3bc 28 03		        jr z, PRS2 
f3be 06 01		        ld b, $01               ; default is to print character in A once 
f3c0 4f			        ld c, a 
f3c1 79			PRS2:   ld a, c                 ; print character in C, B times 
f3c2 cd cd f3		        call XCHROUT 
f3c5 10 fa		        djnz PRS2 
f3c7 c1			        pop bc 
f3c8 18 d5		        jr PRS 
f3ca			 
f3ca			 
f3ca cd e9 00		XCHRIN: call L_00E9 
f3cd fe 3c		XCHROUT:cp $3C 
f3cf 28 0a		        jr z, L_F3DB 
f3d1 fe 0d		        cp $0D 
f3d3 c2 ec 00		        jp nz, L_00EC 
f3d6 3e 0a		        ld a, $0A 
f3d8 cd ec 00		        call L_00EC 
f3db 3e 0d		L_F3DB: ld a, $0D 
f3dd cd ec 00		        call L_00EC 
f3e0 c9			        ret 
f3e1			 
f3e1			 
f3e1 f5			PUTIVC: push af 
f3e2 db b2		L_F3E2: in a, (IVCSTA) 
f3e4 0f			        rrca 
f3e5 38 fb		        jr c, L_F3E2 
f3e7 f1			        pop af 
f3e8 d3 b1		        out (IVCDAT), a 
f3ea c9			        ret 
f3eb			 
f3eb			 
f3eb f5			PUTSER: push af 
f3ec db 42		L_F3EC: in a, ($42) 
f3ee e6 04		        and $04 
f3f0 28 fa		        jr z, L_F3EC 
f3f2 3e 10		L_F3F2: ld a, $10 
f3f4 d3 42		        out ($42), a 
f3f6 db 42		        in a, ($42) 
f3f8 e6 20		        and $20 
f3fa 28 f6		        jr z, L_F3F2 
f3fc f1			        pop af 
f3fd e6 7f		        and $7F 
f3ff d3 40		        out ($40), a 
f401 c9			        ret 
f402			 
f402			 
f402 3e 1b		POLIVC: ld a, $1B               ; check IVC keyboard status return with Z if no character 
f404 cd e1 f3		        call PUTIVC             ; else fall through to get character 
f407 3e 6b		        ld a, $6B 
f409 cd e1 f3		        call PUTIVC 
f40c cd 27 f4		        call INIVC 
f40f b7			        or a 
f410 c8			        ret z                   ; no character 
f411 3e 1b		GETIVC: ld a, $1B               ; get character from IVC kbd (wait if necessary). Return with character in A 
f413 cd e1 f3		        call PUTIVC             ; -- force a-z to upper case. 
f416 3e 4b		        ld a, $4B               ; get character 
f418 cd e1 f3		        call PUTIVC 
f41b cd 27 f4		        call INIVC 
f41e fe 61		L_F41E: cp $61                  ; "a" 
f420 d8			        ret c 
f421 fe 7b		        cp $7B                  ; "z" + 1 
f423 d0			        ret nc 
f424 e6 5f		        and $5F                 ; force alphabetic to upper case 
f426 c9			        ret 
f427			 
f427			 
f427 db b2		INIVC:  in a, (IVCSTA)          ; wait for byte from IVC 
f429 07			        rlca 
f42a 38 fb		        jr c, INIVC 
f42c db b1		        in a, (IVCDAT) 
f42e c9			        ret 
f42f			 
f42f			 
f42f db 42		POLSER: in a, ($42)             ; check for character from serial 
f431 e6 01		        and $01 
f433 c8			        ret z 
f434 db 42		GETSER: in a, ($42)             ; block, waiting for character from serial 
f436 e6 01		        and $01 
f438 28 fa		        jr z, GETSER 
f43a db 40		        in a, ($40) 
f43c e6 7f		        and $7F 
f43e 18 de		        jr L_F41E 
f440			 
f440			 
f440 21 60 f4		CMD_A:  ld hl, MSG6             ; select master drive 
f443 cd 9f f3		        call PRS 
f446 cd e9 00		L_F446: call L_00E9             ; get character 
f449 d6 31		        sub $31 
f44b 38 f9		        jr c, L_F446            ; illegal 
f44d fe 04		        cp $04                  ; 1-4 are legal (not 1-2 per message) 
f44f 30 f5		        jr nc, L_F446           ; illegal 
f451 0e 00		        ld c, $00 
f453 47			L_F453: ld b, a                 ; common path for CMD_A, CMD_8; C differs 
f454 04			        inc b 
f455 af			        xor a 
f456 37			        scf 
f457 17			L_F457: rla 
f458 10 fd		        djnz L_F457 
f45a b1			        or c 
f45b cb 7f		        bit 7, a 
f45d c3 63 f0		        jp L_F063 
f460			 
f460			 
f460 0d			MSG6:   defb $0D 
f461 ..			        defm "Select master Drive (1 or 2) " 
f47e 00			        defb $00 
f47f			 
f47f			 
f47f 21 94 f4		CMD_8:  ld hl, MSG7             ; select 8" drive.. 
f482 cd 9f f3		        call PRS 
f485 cd e9 00		CMD81:  call L_00E9             ; get character 
f488 d6 31		        sub $31 
f48a 38 f9		        jr c, CMD81             ; illegal 
f48c fe 04		        cp $04                  ; 1-4 are legal 
f48e 30 f5		        jr nc, CMD81            ; illegal 
f490 0e 30		        ld c, $30 
f492 18 bf		        jr L_F453 
f494			 
f494			 
f494 0d			MSG7:   defb $0D 
f495 ..			        defm "Select 8\" Drive (1-4) " 
f4ab 00			        defb $00 
f4ac			 
f4ac ..			MSG8:   defm "  " 
f4ae 1a 0a 0a 0a 09	        defb $1A, $0A, $0A, $0A, $09 
f4b3 ..			        defm "Timeclaim DX3 System @" 
f4c9 0d 0a 0a 00	        defb $0D, $0A, $0A, $00 
f4cd			 
f4cd ..			MSG9:   defm "This is spare"    ; never referenced 
f4da			 
f4da 0d 0a		MSG18:  defb $0D, $0A 
f4dc ..			        defm "       SImple MONitor Version 4.5S" 
f4fe 0d 0a 00		        defb $0D, $0A, $00 
f501			 
f501 ..			MSG10:  defm "         GM809/829 present" 
f51b 0d 0a 00		        defb $0D, $0A, $00 
f51e			 
f51e ..			MSG11:  defm "         GM849/849A present" 
f539 0d 0a 00		        defb $0D, $0A, $00 
f53c			 
f53c			 
f53c af			L_F53C: xor a 
f53d d3 e4		        out (FDCDRV), a         ; turn off all the drives 
f53f 21 da f4		        ld hl, MSG18            ; SIMON banner 
f542 cd 9f f3		        call PRS 
f545 3e 0f		        ld a, $0F 
f547 d3 e5		        out (SCSCTL), a 
f549 db e5		        in a, (SCSCTL) 
f54b 07			        rlca 
f54c 21 1e f5		        ld hl, MSG11            ; detected GM849 disk controller 
f54f 30 03		        jr nc, L_F554 
f551 21 01 f5		        ld hl, MSG10            ; detected GM809/829 disk controller 
f554 cd 9f f3		L_F554: call PRS 
f557 31 e6 00		CMDLOP: ld sp, L_00E6 
f55a 3e 3e		        ld a, ">"               ; prompt 
f55c cd cd f3		        call XCHROUT 
f55f cd cd f3		        call XCHROUT 
f562 21 57 f5		        ld hl, CMDLOP           ; each command ends with RET which takes it back to CMDLOP 
f565 e5			        push hl 
f566 cd ca f3		        call XCHRIN             ; get single-letter command 
f569 fe 41		        cp $41 
f56b ca 40 f4		        jp z, CMD_A 
f56e fe 42		        cp $42 
f570 ca b0 f5		        jp z, CMD_B 
f573 fe 43		        cp $43 
f575 ca 3d f6		        jp z, CMD_C 
f578 fe 47		        cp $47 
f57a ca 50 f6		        jp z, CMD_G 
f57d fe 46		        cp $46 
f57f ca 54 f6		        jp z, CMD_F 
f582 fe 53		        cp $53 
f584 ca 6b f6		        jp z, CMD_S 
f587 fe 4f		        cp $4F 
f589 ca a4 f6		        jp z, CMD_O             ; out to port 
f58c fe 51		        cp $51 
f58e ca b8 f6		        jp z, CMD_Q             ; query from port 
f591 fe 44		        cp $44 
f593 ca c9 f6		        jp z, CMD_D 
f596 fe 56		        cp $56 
f598 ca f5 f6		        jp z, CMD_V 
f59b fe 38		        cp $38 
f59d ca 7f f4		        jp z, CMD_8 
f5a0 21 a6 f5		CMDERR: ld hl, MSG12 
f5a3 c3 9f f3		        jp PRS                  ; print and return (tail-recurse) 
f5a6			 
f5a6			 
f5a6 ..			MSG12:  defm "  -What?" 
f5ae 0d 00		        defb $0D, $00 
f5b0			 
f5b0			 
f5b0 3a ef 00		CMD_B:  ld a, ($00EF)           ; get drive 
f5b3 c3 63 f0		        jp L_F063 
f5b6			 
f5b6			 
f5b6 fe 30		        cp $30                  ; TODO what is this for and how does it get executed? 
f5b8 d8			        ret c 
f5b9 fe 3a		        cp $3A 
f5bb 38 09		        jr c, L_F5C6 
f5bd fe 41		        cp $41 
f5bf d8			        ret c 
f5c0 fe 47		        cp $47 
f5c2 3f			        ccf 
f5c3 d8			        ret c 
f5c4 d6 07		        sub $07 
f5c6 e6 0f		L_F5C6: and $0F 
f5c8 c9			        ret 
f5c9			 
f5c9			 
f5c9 7c			XP4HEX: ld a, h 
f5ca cd ce f5		        call XP2HEX 
f5cd 7d			        ld a, l 
f5ce f5			XP2HEX: push af 
f5cf 0f			        rrca 
f5d0 0f			        rrca 
f5d1 0f			        rrca 
f5d2 0f			        rrca 
f5d3 cd d7 f5		        call L_F5D7 
f5d6 f1			        pop af 
f5d7 e6 0f		L_F5D7: and $0F 
f5d9 c6 90		        add a, $90 
f5db 27			        daa 
f5dc ce 40		        adc a, $40 
f5de 27			        daa 
f5df c3 cd f3		        jp XCHROUT 
f5e2			 
f5e2			 
f5e2 3e 0d		XCRLF:  ld a, $0D 
f5e4 c3 cd f3		        jp XCHROUT 
f5e7			 
f5e7			 
f5e7 3e 20		XSPACE: ld a, $20 
f5e9 c3 cd f3		        jp XCHROUT 
f5ec			 
f5ec			 
f5ec			;;; Get ASCII character "0"-"9", "A"-"F" and return as hex value 0-f 
f5ec			;;; Return value in A. C set if bad character 
f5ec cd ca f3		L_F5EC: call XCHRIN 
f5ef fe 30		        cp $30 
f5f1 d8			        ret c 
f5f2 fe 3a		        cp $3A 
f5f4 38 09		        jr c, L_F5FF 
f5f6 fe 41		        cp $41 
f5f8 d8			        ret c 
f5f9 fe 47		        cp $47 
f5fb 3f			        ccf 
f5fc d8			        ret c 
f5fd d6 07		        sub $07 
f5ff e6 0f		L_F5FF: and $0F 
f601 c9			        ret 
f602			 
f602			 
f602 21 00 00		L_F602: ld hl, $0000 
f605 cd ec f5		        call L_F5EC 
f608 30 06		        jr nc, L_F610 
f60a fe 20		        cp $20 
f60c 28 f4		        jr z, L_F602 
f60e 37			        scf 
f60f c9			        ret 
f610			 
f610			 
f610 29			L_F610: add hl, hl 
f611 d8			        ret c 
f612 29			        add hl, hl 
f613 d8			        ret c 
f614 29			        add hl, hl 
f615 d8			        ret c 
f616 29			        add hl, hl 
f617 d8			        ret c 
f618 85			        add a, l 
f619 6f			        ld l, a 
f61a cd ec f5		        call L_F5EC 
f61d 30 f1		        jr nc, L_F610 
f61f fe 20		        cp $20 
f621 c8			        ret z 
f622 fe 0d		        cp $0D 
f624 c8			        ret z 
f625 37			        scf 
f626 c9			        ret 
f627			 
f627			 
f627 cd 02 f6		GET16: call L_F602              ; get 16-bit value in HL (not at end of line) 
f62a 38 03		        jr c, L_F62F 
f62c fe 20		        cp $20 
f62e c8			        ret z 
f62f e1			L_F62F: pop hl 
f630 c3 a0 f5		        jp CMDERR 
f633			 
f633			 
f633 cd 02 f6		GET16F: call L_F602             ; get final 16-bit value to HL (expect end-of-line else error) 
f636 38 f7		        jr c, L_F62F 
f638 fe 0d		        cp $0D 
f63a c8			        ret z 
f63b 18 f2		        jr L_F62F 
f63d			 
f63d			 
f63d			;;; copy from to length (not intelligent so can overwrite source) 
f63d cd 27 f6		CMD_C:  call GET16              ; from address 
f640 eb			        ex de, hl 
f641 cd 27 f6		        call GET16              ; to address 
f644 44			        ld b, h 
f645 4d			        ld c, l 
f646 cd 33 f6		        call GET16F             ; length 
f649 c5			        push bc 
f64a e3			        ex (sp), hl 
f64b c1			        pop bc 
f64c eb			        ex de, hl 
f64d ed b0		        ldir 
f64f c9			        ret 
f650			 
f650			 
f650			;;; go (execute) at address 
f650 cd 33 f6		CMD_G:  call GET16F            ; get address in HL terminated by end-of-line 
f653 e9			        jp (hl) 
f654			 
f654			 
f654			;;; fill from length byte 
f654 cd 27 f6		CMD_F:  call GET16              ; get from address in HL 
f657 eb			        ex de, hl 
f658 cd 27 f6		        call GET16              ; get length in HL 
f65b ed 52		        sbc hl, de 
f65d d8			        ret c 
f65e 44			        ld b, h 
f65f 4d			        ld c, l 
f660 cd 33 f6		        call GET16F             ; get fill-value in HL terminated by end-of-line 
f663 eb			        ex de, hl 
f664 73			        ld (hl), e 
f665 54			        ld d, h 
f666 5d			        ld e, l 
f667 13			        inc de 
f668 ed b0		        ldir 
f66a c9			        ret 
f66b			 
f66b			 
f66b			;;; Inspect and modify memory 
f66b cd 33 f6		CMD_S:  call GET16F             ; get address in HL terminated by end-of-line 
f66e cd c9 f5		SLOP:   call XP4HEX             ; print it 
f671 3e 2d		        ld a, "-" 
f673 cd cd f3		        call XCHROUT 
f676 7e			        ld a, (hl) 
f677 cd ce f5		        call XP2HEX             ; report byte value at address 
f67a cd e7 f5		        call XSPACE 
f67d eb			        ex de, hl 
f67e cd 02 f6		        call L_F602             ; enter new value or <return> to go to next or - to go back or space to exit? 
f681 eb			        ex de, hl 
f682 f5			        push af 
f683 fe 0d		        cp $0D 
f685 c4 e2 f5		        call nz, XCRLF 
f688 f1			        pop af 
f689 30 0b		        jr nc, L_F696 
f68b fe 0d		        cp $0D 
f68d 28 06		        jr z, L_F695 
f68f fe 2d		        cp "-" 
f691 c0			        ret nz 
f692 2b			        dec hl                  ; previous memory location 
f693 18 d9		        jr SLOP                 ; loop 
f695			 
f695			 
f695 5e			L_F695: ld e, (hl) 
f696 7a			L_F696: ld a, d 
f697 b7			        or a 
f698 c2 a0 f5		        jp nz, CMDERR 
f69b 73			        ld (hl), e 
f69c 7e			        ld a, (hl) 
f69d bb			        cp e 
f69e c2 a0 f5		        jp nz, CMDERR 
f6a1 23			        inc hl                  ; next memory location 
f6a2 18 ca		        jr SLOP                 ; loop 
f6a4			 
f6a4			 
f6a4			;;; Output (write) to I/O port 
f6a4 cd 27 f6		CMD_O:  call GET16              ; get port address in HL 
f6a7 7c			        ld a, h 
f6a8 b7			        or a 
f6a9 c2 a0 f5		        jp nz, CMDERR           ; error: expect port 0-ff therefore H should be 0 
f6ac 4d			        ld c, l 
f6ad cd 33 f6		        call GET16F             ; get value in HL terminated in end-of-line 
f6b0 7c			        ld a, h 
f6b1 b7			        or a 
f6b2 c2 a0 f5		        jp nz, CMDERR           ; error: expect value 0-ff therefore H should be 0 
f6b5 ed 69		        out (c), l              ; write to port 
f6b7 c9			        ret                     ; done 
f6b8			 
f6b8			 
f6b8			;;; Query (read from) I/O port 
f6b8 cd 33 f6		CMD_Q:  call GET16F             ; get port address in HL terminated in end-of-line 
f6bb 7c			        ld a, h 
f6bc b7			        or a 
f6bd c2 a0 f5		        jp nz, CMDERR           ; error: expect port 0-ff therefore H should be 0 
f6c0 4d			        ld c, l                 ; port in C 
f6c1 ed 78		        in a, (c)               ; read from port 
f6c3 cd ce f5		        call XP2HEX             ; print 8-bit value 
f6c6 c3 e2 f5		        jp XCRLF                ; CR and return (tail-recurse) 
f6c9			 
f6c9			 
f6c9			;;; Display memory 
f6c9 cd 27 f6		CMD_D:  call GET16              ; start address 
f6cc eb			        ex de, hl 
f6cd cd 33 f6		        call GET16F             ; number of lines, 16-bytes per line 
f6d0 4d			        ld c, l 
f6d1 eb			        ex de, hl 
f6d2 cd c9 f5		DADDR:  call XP4HEX 
f6d5 06 10		        ld b, $10               ; 16 bytes per line 
f6d7 cd e7 f5		DDATA:  call XSPACE 
f6da 7e			        ld a, (hl) 
f6db cd ce f5		        call XP2HEX             ; print byte 
f6de 23			        inc hl                  ; next address 
f6df 3e 09		        ld a, $09 
f6e1 b8			        cp b 
f6e2 20 08		        jr nz, L_F6EC 
f6e4 cd e7 f5		        call XSPACE 
f6e7 3e 2d		        ld a, "-"               ; " - " between first 8 and second 8 bytes 
f6e9 cd cd f3		        call XCHROUT 
f6ec 10 e9		L_F6EC: djnz DDATA 
f6ee cd e2 f5		L_F6EE: call XCRLF 
f6f1 0d			        dec c                   ; line count 
f6f2 20 de		        jr nz, DADDR 
f6f4 c9			        ret 
f6f5			 
f6f5			 
f6f5			;;; Report version 
f6f5 21 25 f0		CMD_V:  ld hl, MSG20 
f6f8 c3 9f f3		        jp PRS                  ; print and return (tail-recurse) 
f6fb			 
f6fb			 
f6fb			;;; The rest of the ROM image is unreachable code. It looks like a "high tide mark" of older assembly runs 
f6fb			;;; that have been left in memory and which ended up in the ROM. 
f6fb			 
f6fb			;;; TODO unreachable code. This looks like a fragment of the end of CMD_S 
f6fb ff ff ff ff ff ff ff	        defb $FF, $FF, $FF, $FF, $FF, $FF, $FF 
f702 f5			        push af 
f703 fe 0d		        cp $0D 
f705 c4 e2 f5		        call nz, XCRLF 
f708 f1			        pop af 
f709 30 0b		        jr nc, L_F716 
f70b fe 0d		        cp $0D 
f70d 28 06		        jr z, L_F715 
f70f fe 2d		        cp $2D 
f711 c0			        ret nz 
f712 2b			        dec hl 
f713 18 d9		        jr L_F6EE 
f715			 
f715			 
f715			;;; TODO unreachable code - more of CMD_S 
f715 5e			L_F715: ld e, (hl) 
f716 7a			L_F716: ld a, d 
f717 b7			        or a 
f718 c2 a0 f5		        jp nz, CMDERR 
f71b 73			        ld (hl), e 
f71c 7e			        ld a, (hl) 
f71d bb			        cp e 
f71e c2 a0 f5		        jp nz, CMDERR 
f721 23			        inc hl 
f722 18 ca		        jr L_F6EE 
f724			 
f724 cd 27 f6		        call GET16 
f727 7c			        ld a, h 
f728 b7			        or a 
f729 c2 a0 f5		        jp nz, CMDERR 
f72c 4d			        ld c, l 
f72d cd 33 f6		        call GET16F 
f730 7c			        ld a, h 
f731 b7			        or a 
f732 c2 a0 f5		        jp nz, CMDERR 
f735 ed 69		        out (c), l 
f737 c9			        ret 
f738			 
f738			;;; looks like a copy of CMD_O 
f738 cd 33 f6		        call GET16F 
f73b 7c			        ld a, h 
f73c b7			        or a 
f73d c2 a0 f5		        jp nz, CMDERR 
f740 4d			        ld c, l 
f741 ed 78		        in a, (c) 
f743 cd ce f5		        call XP2HEX 
f746 c3 e2 f5		        jp XCRLF 
f749			 
f749			;;; looks like a copy of CMD_D 
f749 cd 27 f6		        call GET16 
f74c eb			        ex de, hl 
f74d cd 33 f6		        call GET16F 
f750 4d			        ld c, l 
f751 eb			        ex de, hl 
f752 cd c9 f5		L_F752: call XP4HEX 
f755 06 10		        ld b, $10 
f757 cd e7 f5		L_F757: call XSPACE 
f75a 7e			        ld a, (hl) 
f75b cd ce f5		        call XP2HEX 
f75e 23			        inc hl 
f75f 3e 09		        ld a, $09 
f761 b8			        cp b 
f762 20 08		        jr nz, L_F76C 
f764 cd e7 f5		        call XSPACE 
f767 3e 2d		        ld a, $2D 
f769 cd cd f3		        call XCHROUT 
f76c 10 e9		L_F76C: djnz L_F757 
f76e cd e2 f5		        call XCRLF 
f771 0d			        dec c 
f772 20 de		        jr nz, L_F752 
f774 c9			        ret 
f775			 
f775			;;; looks like a copy of the start of CMD_V 
f775 21 25 f0		        ld hl, MSG20 
f778 c3 9f f3		        jp PRS 
f77b			 
f77b ff ff ff ff ff	        defb $FF, $FF, $FF, $FF, $FF 
f780 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff	        defb $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF 
f790 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff	        defb $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF 
f7a0 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff	        defb $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF 
f7b0 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff	        defb $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF 
f7c0 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff	        defb $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF 
f7d0 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff	        defb $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF 
f7e0 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff	        defb $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF 
f7f0 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff	        defb $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF 
# End of file simon45s.asm
f800
